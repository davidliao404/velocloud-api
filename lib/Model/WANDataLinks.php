<?php
/**
 * WANDataLinks
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Velocloud API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 3.0.2
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.3.1
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;
use \Swagger\Client\ObjectSerializer;

/**
 * WANDataLinks Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class WANDataLinks implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'WAN_data_links';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'logical_id' => 'string',
        'internal_id' => 'string',
        'discovery' => 'string',
        'mode' => 'string',
        'type' => 'string',
        'name' => 'string',
        'isp' => 'string',
        'public_ip_address' => 'string',
        'source_ip_address' => 'string',
        'next_hop_ip_address' => 'string',
        'custom_vlan_id' => 'bool',
        'vlan_id' => 'int',
        'virtual_ip_address' => 'string',
        'dynamic_bw_adjustment_enabled' => 'bool',
        'bw_measurement' => 'string',
        'upstream_mbps' => 'string',
        'downstream_mbps' => 'string',
        'backup_only' => 'bool',
        'overhead_bytes' => 'int',
        'udp_hole_punching' => 'bool',
        'mtu' => 'int',
        'mpls_network' => 'string',
        'dscp_tag' => 'string',
        'static_sla_enabled' => 'bool',
        'classesof_service_enabled' => 'bool',
        'encrypt_overlay' => 'bool',
        'static_sla' => '\Swagger\Client\Model\WANDataStaticSLA',
        'classes_of_service' => '\Swagger\Client\Model\WANDataClassesOfService',
        'interfaces' => 'string[]',
        'last_active' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'logical_id' => null,
        'internal_id' => null,
        'discovery' => null,
        'mode' => null,
        'type' => null,
        'name' => null,
        'isp' => null,
        'public_ip_address' => null,
        'source_ip_address' => null,
        'next_hop_ip_address' => null,
        'custom_vlan_id' => null,
        'vlan_id' => null,
        'virtual_ip_address' => null,
        'dynamic_bw_adjustment_enabled' => null,
        'bw_measurement' => null,
        'upstream_mbps' => null,
        'downstream_mbps' => null,
        'backup_only' => null,
        'overhead_bytes' => null,
        'udp_hole_punching' => null,
        'mtu' => null,
        'mpls_network' => null,
        'dscp_tag' => null,
        'static_sla_enabled' => null,
        'classesof_service_enabled' => null,
        'encrypt_overlay' => null,
        'static_sla' => null,
        'classes_of_service' => null,
        'interfaces' => null,
        'last_active' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'logical_id' => 'logicalId',
        'internal_id' => 'internalId',
        'discovery' => 'discovery',
        'mode' => 'mode',
        'type' => 'type',
        'name' => 'name',
        'isp' => 'isp',
        'public_ip_address' => 'publicIpAddress',
        'source_ip_address' => 'sourceIpAddress',
        'next_hop_ip_address' => 'nextHopIpAddress',
        'custom_vlan_id' => 'customVlanId',
        'vlan_id' => 'vlanId',
        'virtual_ip_address' => 'virtualIpAddress',
        'dynamic_bw_adjustment_enabled' => 'dynamicBwAdjustmentEnabled',
        'bw_measurement' => 'bwMeasurement',
        'upstream_mbps' => 'upstreamMbps',
        'downstream_mbps' => 'downstreamMbps',
        'backup_only' => 'backupOnly',
        'overhead_bytes' => 'overheadBytes',
        'udp_hole_punching' => 'udpHolePunching',
        'mtu' => 'MTU',
        'mpls_network' => 'mplsNetwork',
        'dscp_tag' => 'dscpTag',
        'static_sla_enabled' => 'staticSlaEnabled',
        'classesof_service_enabled' => 'classesofServiceEnabled',
        'encrypt_overlay' => 'encryptOverlay',
        'static_sla' => 'staticSLA',
        'classes_of_service' => 'classesOfService',
        'interfaces' => 'interfaces',
        'last_active' => 'lastActive'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'logical_id' => 'setLogicalId',
        'internal_id' => 'setInternalId',
        'discovery' => 'setDiscovery',
        'mode' => 'setMode',
        'type' => 'setType',
        'name' => 'setName',
        'isp' => 'setIsp',
        'public_ip_address' => 'setPublicIpAddress',
        'source_ip_address' => 'setSourceIpAddress',
        'next_hop_ip_address' => 'setNextHopIpAddress',
        'custom_vlan_id' => 'setCustomVlanId',
        'vlan_id' => 'setVlanId',
        'virtual_ip_address' => 'setVirtualIpAddress',
        'dynamic_bw_adjustment_enabled' => 'setDynamicBwAdjustmentEnabled',
        'bw_measurement' => 'setBwMeasurement',
        'upstream_mbps' => 'setUpstreamMbps',
        'downstream_mbps' => 'setDownstreamMbps',
        'backup_only' => 'setBackupOnly',
        'overhead_bytes' => 'setOverheadBytes',
        'udp_hole_punching' => 'setUdpHolePunching',
        'mtu' => 'setMtu',
        'mpls_network' => 'setMplsNetwork',
        'dscp_tag' => 'setDscpTag',
        'static_sla_enabled' => 'setStaticSlaEnabled',
        'classesof_service_enabled' => 'setClassesofServiceEnabled',
        'encrypt_overlay' => 'setEncryptOverlay',
        'static_sla' => 'setStaticSla',
        'classes_of_service' => 'setClassesOfService',
        'interfaces' => 'setInterfaces',
        'last_active' => 'setLastActive'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'logical_id' => 'getLogicalId',
        'internal_id' => 'getInternalId',
        'discovery' => 'getDiscovery',
        'mode' => 'getMode',
        'type' => 'getType',
        'name' => 'getName',
        'isp' => 'getIsp',
        'public_ip_address' => 'getPublicIpAddress',
        'source_ip_address' => 'getSourceIpAddress',
        'next_hop_ip_address' => 'getNextHopIpAddress',
        'custom_vlan_id' => 'getCustomVlanId',
        'vlan_id' => 'getVlanId',
        'virtual_ip_address' => 'getVirtualIpAddress',
        'dynamic_bw_adjustment_enabled' => 'getDynamicBwAdjustmentEnabled',
        'bw_measurement' => 'getBwMeasurement',
        'upstream_mbps' => 'getUpstreamMbps',
        'downstream_mbps' => 'getDownstreamMbps',
        'backup_only' => 'getBackupOnly',
        'overhead_bytes' => 'getOverheadBytes',
        'udp_hole_punching' => 'getUdpHolePunching',
        'mtu' => 'getMtu',
        'mpls_network' => 'getMplsNetwork',
        'dscp_tag' => 'getDscpTag',
        'static_sla_enabled' => 'getStaticSlaEnabled',
        'classesof_service_enabled' => 'getClassesofServiceEnabled',
        'encrypt_overlay' => 'getEncryptOverlay',
        'static_sla' => 'getStaticSla',
        'classes_of_service' => 'getClassesOfService',
        'interfaces' => 'getInterfaces',
        'last_active' => 'getLastActive'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const DISCOVERY_DISABLED = 'DISABLED';
    const DISCOVERY_AUTO_DISCOVERED = 'AUTO_DISCOVERED';
    const DISCOVERY_USER_DEFINED = 'USER_DEFINED';
    const MODE__PUBLIC = 'PUBLIC';
    const MODE__PRIVATE = 'PRIVATE';
    const TYPE_WIRED = 'WIRED';
    const TYPE_WIRELESS = 'WIRELESS';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getDiscoveryAllowableValues()
    {
        return [
            self::DISCOVERY_DISABLED,
            self::DISCOVERY_AUTO_DISCOVERED,
            self::DISCOVERY_USER_DEFINED,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getModeAllowableValues()
    {
        return [
            self::MODE__PUBLIC,
            self::MODE__PRIVATE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTypeAllowableValues()
    {
        return [
            self::TYPE_WIRED,
            self::TYPE_WIRELESS,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['logical_id'] = isset($data['logical_id']) ? $data['logical_id'] : null;
        $this->container['internal_id'] = isset($data['internal_id']) ? $data['internal_id'] : null;
        $this->container['discovery'] = isset($data['discovery']) ? $data['discovery'] : null;
        $this->container['mode'] = isset($data['mode']) ? $data['mode'] : null;
        $this->container['type'] = isset($data['type']) ? $data['type'] : null;
        $this->container['name'] = isset($data['name']) ? $data['name'] : null;
        $this->container['isp'] = isset($data['isp']) ? $data['isp'] : null;
        $this->container['public_ip_address'] = isset($data['public_ip_address']) ? $data['public_ip_address'] : null;
        $this->container['source_ip_address'] = isset($data['source_ip_address']) ? $data['source_ip_address'] : null;
        $this->container['next_hop_ip_address'] = isset($data['next_hop_ip_address']) ? $data['next_hop_ip_address'] : null;
        $this->container['custom_vlan_id'] = isset($data['custom_vlan_id']) ? $data['custom_vlan_id'] : null;
        $this->container['vlan_id'] = isset($data['vlan_id']) ? $data['vlan_id'] : null;
        $this->container['virtual_ip_address'] = isset($data['virtual_ip_address']) ? $data['virtual_ip_address'] : null;
        $this->container['dynamic_bw_adjustment_enabled'] = isset($data['dynamic_bw_adjustment_enabled']) ? $data['dynamic_bw_adjustment_enabled'] : null;
        $this->container['bw_measurement'] = isset($data['bw_measurement']) ? $data['bw_measurement'] : null;
        $this->container['upstream_mbps'] = isset($data['upstream_mbps']) ? $data['upstream_mbps'] : null;
        $this->container['downstream_mbps'] = isset($data['downstream_mbps']) ? $data['downstream_mbps'] : null;
        $this->container['backup_only'] = isset($data['backup_only']) ? $data['backup_only'] : null;
        $this->container['overhead_bytes'] = isset($data['overhead_bytes']) ? $data['overhead_bytes'] : null;
        $this->container['udp_hole_punching'] = isset($data['udp_hole_punching']) ? $data['udp_hole_punching'] : null;
        $this->container['mtu'] = isset($data['mtu']) ? $data['mtu'] : null;
        $this->container['mpls_network'] = isset($data['mpls_network']) ? $data['mpls_network'] : null;
        $this->container['dscp_tag'] = isset($data['dscp_tag']) ? $data['dscp_tag'] : null;
        $this->container['static_sla_enabled'] = isset($data['static_sla_enabled']) ? $data['static_sla_enabled'] : null;
        $this->container['classesof_service_enabled'] = isset($data['classesof_service_enabled']) ? $data['classesof_service_enabled'] : null;
        $this->container['encrypt_overlay'] = isset($data['encrypt_overlay']) ? $data['encrypt_overlay'] : null;
        $this->container['static_sla'] = isset($data['static_sla']) ? $data['static_sla'] : null;
        $this->container['classes_of_service'] = isset($data['classes_of_service']) ? $data['classes_of_service'] : null;
        $this->container['interfaces'] = isset($data['interfaces']) ? $data['interfaces'] : null;
        $this->container['last_active'] = isset($data['last_active']) ? $data['last_active'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getDiscoveryAllowableValues();
        if (!in_array($this->container['discovery'], $allowedValues)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'discovery', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getModeAllowableValues();
        if (!in_array($this->container['mode'], $allowedValues)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'mode', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getTypeAllowableValues();
        if (!in_array($this->container['type'], $allowedValues)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {

        $allowedValues = $this->getDiscoveryAllowableValues();
        if (!in_array($this->container['discovery'], $allowedValues)) {
            return false;
        }
        $allowedValues = $this->getModeAllowableValues();
        if (!in_array($this->container['mode'], $allowedValues)) {
            return false;
        }
        $allowedValues = $this->getTypeAllowableValues();
        if (!in_array($this->container['type'], $allowedValues)) {
            return false;
        }
        return true;
    }


    /**
     * Gets logical_id
     *
     * @return string
     */
    public function getLogicalId()
    {
        return $this->container['logical_id'];
    }

    /**
     * Sets logical_id
     *
     * @param string $logical_id logical_id
     *
     * @return $this
     */
    public function setLogicalId($logical_id)
    {
        $this->container['logical_id'] = $logical_id;

        return $this;
    }

    /**
     * Gets internal_id
     *
     * @return string
     */
    public function getInternalId()
    {
        return $this->container['internal_id'];
    }

    /**
     * Sets internal_id
     *
     * @param string $internal_id internal_id
     *
     * @return $this
     */
    public function setInternalId($internal_id)
    {
        $this->container['internal_id'] = $internal_id;

        return $this;
    }

    /**
     * Gets discovery
     *
     * @return string
     */
    public function getDiscovery()
    {
        return $this->container['discovery'];
    }

    /**
     * Sets discovery
     *
     * @param string $discovery discovery
     *
     * @return $this
     */
    public function setDiscovery($discovery)
    {
        $allowedValues = $this->getDiscoveryAllowableValues();
        if (!is_null($discovery) && !in_array($discovery, $allowedValues)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'discovery', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['discovery'] = $discovery;

        return $this;
    }

    /**
     * Gets mode
     *
     * @return string
     */
    public function getMode()
    {
        return $this->container['mode'];
    }

    /**
     * Sets mode
     *
     * @param string $mode mode
     *
     * @return $this
     */
    public function setMode($mode)
    {
        $allowedValues = $this->getModeAllowableValues();
        if (!is_null($mode) && !in_array($mode, $allowedValues)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'mode', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['mode'] = $mode;

        return $this;
    }

    /**
     * Gets type
     *
     * @return string
     */
    public function getType()
    {
        return $this->container['type'];
    }

    /**
     * Sets type
     *
     * @param string $type type
     *
     * @return $this
     */
    public function setType($type)
    {
        $allowedValues = $this->getTypeAllowableValues();
        if (!is_null($type) && !in_array($type, $allowedValues)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['type'] = $type;

        return $this;
    }

    /**
     * Gets name
     *
     * @return string
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string $name name
     *
     * @return $this
     */
    public function setName($name)
    {
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets isp
     *
     * @return string
     */
    public function getIsp()
    {
        return $this->container['isp'];
    }

    /**
     * Sets isp
     *
     * @param string $isp isp
     *
     * @return $this
     */
    public function setIsp($isp)
    {
        $this->container['isp'] = $isp;

        return $this;
    }

    /**
     * Gets public_ip_address
     *
     * @return string
     */
    public function getPublicIpAddress()
    {
        return $this->container['public_ip_address'];
    }

    /**
     * Sets public_ip_address
     *
     * @param string $public_ip_address public_ip_address
     *
     * @return $this
     */
    public function setPublicIpAddress($public_ip_address)
    {
        $this->container['public_ip_address'] = $public_ip_address;

        return $this;
    }

    /**
     * Gets source_ip_address
     *
     * @return string
     */
    public function getSourceIpAddress()
    {
        return $this->container['source_ip_address'];
    }

    /**
     * Sets source_ip_address
     *
     * @param string $source_ip_address source_ip_address
     *
     * @return $this
     */
    public function setSourceIpAddress($source_ip_address)
    {
        $this->container['source_ip_address'] = $source_ip_address;

        return $this;
    }

    /**
     * Gets next_hop_ip_address
     *
     * @return string
     */
    public function getNextHopIpAddress()
    {
        return $this->container['next_hop_ip_address'];
    }

    /**
     * Sets next_hop_ip_address
     *
     * @param string $next_hop_ip_address next_hop_ip_address
     *
     * @return $this
     */
    public function setNextHopIpAddress($next_hop_ip_address)
    {
        $this->container['next_hop_ip_address'] = $next_hop_ip_address;

        return $this;
    }

    /**
     * Gets custom_vlan_id
     *
     * @return bool
     */
    public function getCustomVlanId()
    {
        return $this->container['custom_vlan_id'];
    }

    /**
     * Sets custom_vlan_id
     *
     * @param bool $custom_vlan_id custom_vlan_id
     *
     * @return $this
     */
    public function setCustomVlanId($custom_vlan_id)
    {
        $this->container['custom_vlan_id'] = $custom_vlan_id;

        return $this;
    }

    /**
     * Gets vlan_id
     *
     * @return int
     */
    public function getVlanId()
    {
        return $this->container['vlan_id'];
    }

    /**
     * Sets vlan_id
     *
     * @param int $vlan_id vlan_id
     *
     * @return $this
     */
    public function setVlanId($vlan_id)
    {
        $this->container['vlan_id'] = $vlan_id;

        return $this;
    }

    /**
     * Gets virtual_ip_address
     *
     * @return string
     */
    public function getVirtualIpAddress()
    {
        return $this->container['virtual_ip_address'];
    }

    /**
     * Sets virtual_ip_address
     *
     * @param string $virtual_ip_address virtual_ip_address
     *
     * @return $this
     */
    public function setVirtualIpAddress($virtual_ip_address)
    {
        $this->container['virtual_ip_address'] = $virtual_ip_address;

        return $this;
    }

    /**
     * Gets dynamic_bw_adjustment_enabled
     *
     * @return bool
     */
    public function getDynamicBwAdjustmentEnabled()
    {
        return $this->container['dynamic_bw_adjustment_enabled'];
    }

    /**
     * Sets dynamic_bw_adjustment_enabled
     *
     * @param bool $dynamic_bw_adjustment_enabled dynamic_bw_adjustment_enabled
     *
     * @return $this
     */
    public function setDynamicBwAdjustmentEnabled($dynamic_bw_adjustment_enabled)
    {
        $this->container['dynamic_bw_adjustment_enabled'] = $dynamic_bw_adjustment_enabled;

        return $this;
    }

    /**
     * Gets bw_measurement
     *
     * @return string
     */
    public function getBwMeasurement()
    {
        return $this->container['bw_measurement'];
    }

    /**
     * Sets bw_measurement
     *
     * @param string $bw_measurement bw_measurement
     *
     * @return $this
     */
    public function setBwMeasurement($bw_measurement)
    {
        $this->container['bw_measurement'] = $bw_measurement;

        return $this;
    }

    /**
     * Gets upstream_mbps
     *
     * @return string
     */
    public function getUpstreamMbps()
    {
        return $this->container['upstream_mbps'];
    }

    /**
     * Sets upstream_mbps
     *
     * @param string $upstream_mbps upstream_mbps
     *
     * @return $this
     */
    public function setUpstreamMbps($upstream_mbps)
    {
        $this->container['upstream_mbps'] = $upstream_mbps;

        return $this;
    }

    /**
     * Gets downstream_mbps
     *
     * @return string
     */
    public function getDownstreamMbps()
    {
        return $this->container['downstream_mbps'];
    }

    /**
     * Sets downstream_mbps
     *
     * @param string $downstream_mbps downstream_mbps
     *
     * @return $this
     */
    public function setDownstreamMbps($downstream_mbps)
    {
        $this->container['downstream_mbps'] = $downstream_mbps;

        return $this;
    }

    /**
     * Gets backup_only
     *
     * @return bool
     */
    public function getBackupOnly()
    {
        return $this->container['backup_only'];
    }

    /**
     * Sets backup_only
     *
     * @param bool $backup_only backup_only
     *
     * @return $this
     */
    public function setBackupOnly($backup_only)
    {
        $this->container['backup_only'] = $backup_only;

        return $this;
    }

    /**
     * Gets overhead_bytes
     *
     * @return int
     */
    public function getOverheadBytes()
    {
        return $this->container['overhead_bytes'];
    }

    /**
     * Sets overhead_bytes
     *
     * @param int $overhead_bytes overhead_bytes
     *
     * @return $this
     */
    public function setOverheadBytes($overhead_bytes)
    {
        $this->container['overhead_bytes'] = $overhead_bytes;

        return $this;
    }

    /**
     * Gets udp_hole_punching
     *
     * @return bool
     */
    public function getUdpHolePunching()
    {
        return $this->container['udp_hole_punching'];
    }

    /**
     * Sets udp_hole_punching
     *
     * @param bool $udp_hole_punching udp_hole_punching
     *
     * @return $this
     */
    public function setUdpHolePunching($udp_hole_punching)
    {
        $this->container['udp_hole_punching'] = $udp_hole_punching;

        return $this;
    }

    /**
     * Gets mtu
     *
     * @return int
     */
    public function getMtu()
    {
        return $this->container['mtu'];
    }

    /**
     * Sets mtu
     *
     * @param int $mtu mtu
     *
     * @return $this
     */
    public function setMtu($mtu)
    {
        $this->container['mtu'] = $mtu;

        return $this;
    }

    /**
     * Gets mpls_network
     *
     * @return string
     */
    public function getMplsNetwork()
    {
        return $this->container['mpls_network'];
    }

    /**
     * Sets mpls_network
     *
     * @param string $mpls_network mpls_network
     *
     * @return $this
     */
    public function setMplsNetwork($mpls_network)
    {
        $this->container['mpls_network'] = $mpls_network;

        return $this;
    }

    /**
     * Gets dscp_tag
     *
     * @return string
     */
    public function getDscpTag()
    {
        return $this->container['dscp_tag'];
    }

    /**
     * Sets dscp_tag
     *
     * @param string $dscp_tag dscp_tag
     *
     * @return $this
     */
    public function setDscpTag($dscp_tag)
    {
        $this->container['dscp_tag'] = $dscp_tag;

        return $this;
    }

    /**
     * Gets static_sla_enabled
     *
     * @return bool
     */
    public function getStaticSlaEnabled()
    {
        return $this->container['static_sla_enabled'];
    }

    /**
     * Sets static_sla_enabled
     *
     * @param bool $static_sla_enabled static_sla_enabled
     *
     * @return $this
     */
    public function setStaticSlaEnabled($static_sla_enabled)
    {
        $this->container['static_sla_enabled'] = $static_sla_enabled;

        return $this;
    }

    /**
     * Gets classesof_service_enabled
     *
     * @return bool
     */
    public function getClassesofServiceEnabled()
    {
        return $this->container['classesof_service_enabled'];
    }

    /**
     * Sets classesof_service_enabled
     *
     * @param bool $classesof_service_enabled classesof_service_enabled
     *
     * @return $this
     */
    public function setClassesofServiceEnabled($classesof_service_enabled)
    {
        $this->container['classesof_service_enabled'] = $classesof_service_enabled;

        return $this;
    }

    /**
     * Gets encrypt_overlay
     *
     * @return bool
     */
    public function getEncryptOverlay()
    {
        return $this->container['encrypt_overlay'];
    }

    /**
     * Sets encrypt_overlay
     *
     * @param bool $encrypt_overlay encrypt_overlay
     *
     * @return $this
     */
    public function setEncryptOverlay($encrypt_overlay)
    {
        $this->container['encrypt_overlay'] = $encrypt_overlay;

        return $this;
    }

    /**
     * Gets static_sla
     *
     * @return \Swagger\Client\Model\WANDataStaticSLA
     */
    public function getStaticSla()
    {
        return $this->container['static_sla'];
    }

    /**
     * Sets static_sla
     *
     * @param \Swagger\Client\Model\WANDataStaticSLA $static_sla static_sla
     *
     * @return $this
     */
    public function setStaticSla($static_sla)
    {
        $this->container['static_sla'] = $static_sla;

        return $this;
    }

    /**
     * Gets classes_of_service
     *
     * @return \Swagger\Client\Model\WANDataClassesOfService
     */
    public function getClassesOfService()
    {
        return $this->container['classes_of_service'];
    }

    /**
     * Sets classes_of_service
     *
     * @param \Swagger\Client\Model\WANDataClassesOfService $classes_of_service classes_of_service
     *
     * @return $this
     */
    public function setClassesOfService($classes_of_service)
    {
        $this->container['classes_of_service'] = $classes_of_service;

        return $this;
    }

    /**
     * Gets interfaces
     *
     * @return string[]
     */
    public function getInterfaces()
    {
        return $this->container['interfaces'];
    }

    /**
     * Sets interfaces
     *
     * @param string[] $interfaces interfaces
     *
     * @return $this
     */
    public function setInterfaces($interfaces)
    {
        $this->container['interfaces'] = $interfaces;

        return $this;
    }

    /**
     * Gets last_active
     *
     * @return string
     */
    public function getLastActive()
    {
        return $this->container['last_active'];
    }

    /**
     * Sets last_active
     *
     * @param string $last_active last_active
     *
     * @return $this
     */
    public function setLastActive($last_active)
    {
        $this->container['last_active'] = $last_active;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


